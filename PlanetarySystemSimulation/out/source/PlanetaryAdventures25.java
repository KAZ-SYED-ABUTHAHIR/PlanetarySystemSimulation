/* autogenerated by Processing revision 1276 on 2021-10-22 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class PlanetaryAdventures25 extends PApplet {

//Refactoring On from Iteration 8: 15.06.2018 
//Primary aim of refactoring is to cast SideBar class in a more reusable form
//Emphasis is on Code Reusability...And Don't forget the famous Arrow class

//Grand Success Need not to explicitly draw SideBar. Handled in the SideBar class itself.

// Refactoring after Nearly 3  Years. 22.10.2021 Friday Iteration 25.

Attractor sun;
ArrayList<Planet> planets;
SideBar sb;
SideBar SB;
TextBar txtBar, txtBarSB, txtBarsb;
int highlightedPlanetIndex = -1;

float zoomFactor = 0.575f; //This is the optimal zoom factor for speed...
float zoomStep = 0.01f;

float panX = 0, panY = 0;
float panStep = 5;

float pMouseX, pMouseY;

final boolean showOrbitPoints = false;
PVector velocityAnchor  = new PVector(800, 0);

final int FRAME_RATE = 60;

PImage sbBkImg,SBBkImg;

boolean showTrail = true;

 public void settings(){
  fullScreen();
  smooth(8);
}


 public void setup() {
  SBBkImg = loadImage("JupiterSaturn.jpg");
  sbBkImg = loadImage("outer-space-stars-galaxies-planets-background-images.jpg");
  frameRate(FRAME_RATE);
  surface.setTitle("PLANETARY ADVENTURES: KEPLER'S PARADISE");
  sb = new SideBar(this, 0, 2.5f*width/3, 2*height/3);
  SB = new SideBar(this, 2*height/3, 2*width/3, height/2);
  sb.setImage(sbBkImg);
  SB.setImage(SBBkImg);

  txtBar = new TextBar(10, 10, (sb.getDrawWidth()-20), sb.barHeight/1.8f-10);
  txtBarsb = new TextBar(10, sb.barHeight/1.8f+10, (sb.getDrawWidth()-20), sb.barHeight-(sb.barHeight/1.8f+20));
  txtBarSB = new TextBar(10, 10, (SB.getDrawWidth()-20), SB.barHeight/2-20);

  txtBar.setTextSize(25);
  txtBarSB.setTextSize(25);

  sb.addChild(txtBarsb);
  sb.addChild(txtBar);
  SB.addChild(txtBarSB);

  String message = "Interactivity\n\n" +
    "Click and drag to add a Planet. The arrow represents the velocity vector.\n" +
    "Press \'h\' or \'H\' to cycle through planets for selection.\n" + 
    "Press \'d\' or \'D\' to delete the selected planet.\n" + 
    "Press 'a','s','w' or 'z' for panning\n" +
    "Orbital parameters for the selected planet are shown in the above text field";

  txtBarsb.setText(message); 
  txtBarsb.setTextSize(25);

  sun = new Attractor();
  planets = new ArrayList<Planet>();

  //  thread("calculateForceandUpdate");
  //  background(0);
}

 public void draw() {
  
  if (!mousePressed || sb.inFocus() || SB.inFocus()) {
    if(showTrail){
      fill(0, 8);
      noStroke();
      rect(0, 0, width, height);
    } else {
      background(0);
    }
    
    pushMatrix();

      scale(zoomFactor);
      translate(width/2*(1/zoomFactor), height/2*(1/zoomFactor));
      pan(panX, panY);
      sun.show();

      for (Planet p : planets) {
        p.showOrbit(showOrbitPoints);
      }

      for (Planet p : planets) {
        p.calcForce(sun);
        p.update();
        p.show();
        p.showVelocity();
        p.showAcceleration();
        p.showVelocity(velocityAnchor);
      }

    popMatrix();

    if (frameCount%10 == 0) {
      String debugMsg = "Debug Parameters"+
        "\nFrame Rate   : " + String.format("%.02f", frameRate) +
        "\nZoom Factor : " + String.format("%.02f", zoomFactor)+
        "\nhighlightedPlanetIndex : " + highlightedPlanetIndex;
      txtBarSB.setText(debugMsg, ':');
    }

  }

}


 public void keyPressed() {
  if (key == CODED) {
    if (keyCode == UP) {
      zoomFactor += zoomStep;
      if (zoomFactor>1) zoomFactor = 1;
      background(0);
    } else if (keyCode == DOWN) {
      zoomFactor -= zoomStep;
      if (zoomFactor<0.15f) zoomFactor = 0.15f;
      background(0);
    } else if (keyCode == RIGHT) {
      sb.slideOut();
    } else if (keyCode == LEFT) {
      sb.slideIn();
    }
  } 

  if (key == 'D'||key == 'd') {

    if (planets.size()>0) {
      planets.remove(planets.get(highlightedPlanetIndex++));
      if (highlightedPlanetIndex > (planets.size()-1)) highlightedPlanetIndex = 0;
      if (planets.size()>0) {

        selectPlanet(highlightedPlanetIndex);
      } else {
        txtBar.setText("NO PLANETS AVAILABLE !");
        highlightedPlanetIndex = -1;
      }
      background(0);
    }
  }
  if (key == 'H'||key == 'h') {
    if (planets.size()>0) {
      planets.get(highlightedPlanetIndex++).setHighlighted(false);
      if (highlightedPlanetIndex > (planets.size()-1)) highlightedPlanetIndex = 0;
      selectPlanet(highlightedPlanetIndex);
    }
  }

  if (key == 'a' || key == 'A') {
    panX += panStep;
  } else if (key == 's' || key == 'S') {
    panX -= panStep;
  } else if (key == 'w' || key == 'W') {
    panY += panStep;
  } else if (key == 'z' || key == 'Z') {
    panY -= panStep;
  }

}

 public void selectPlanet(int index) {
  planets.get(index).setHighlighted(true);
  txtBar.setText(planets.get(index).orbitDescriptor, ':');
  sb.setHandleColor(planets.get(index).planetColor);
}

 public void mouseDragged() {
  if (sb.inFocus() || SB.inFocus()) {
    return;
  }
  background(0);
  drawScene();
  Arrow arrow  = new Arrow(pMouseX, pMouseY, mouseX, mouseY);
  arrow.show();
}

 public void mousePressed() {
  if (SB.inFocus() || sb.inFocus()) {
    return;
  }
  pMouseX = mouseX; 
  pMouseY = mouseY;

  noCursor();
}

 public void mouseReleased() {
  if (sb.inFocus() || SB.inFocus()) {
    return;
  }
  addNewPlanet((mouseX - pMouseX)/Planet.velocityArrowScale, (mouseY - pMouseY)/Planet.velocityArrowScale);
  background(0);
  cursor();
}

 public void addNewPlanet(float vx, float vy) {
  pushMatrix();
  //Important piece of transformation , I understand? 
  float x = (pMouseX-width/2)/zoomFactor; 
  float y = (pMouseY-height/2)/zoomFactor;
  float mass = 1.0f;
  Planet p = new Planet(new PVector(x, y), new PVector(vx, vy), mass, sun);
  try {
    planets.add(p);
  }
  catch(Exception e) {
    e.printStackTrace();
  }

  if (planets.size()==1) {
    highlightedPlanetIndex = 0;
    selectPlanet(highlightedPlanetIndex);
  }
  popMatrix();
}

 public void drawScene() {
  background(0);
  pushMatrix();
  scale(zoomFactor);
  translate(width/2*(1/zoomFactor), height/2*(1/zoomFactor));
  pan(panX, panY);
  sun.show();
  popMatrix();
}

 public void pan(float shiftX, float shiftY) {
  translate(shiftX, shiftY);
}

public class Arrow {
  PVector anchor = null;
  PVector head = null;
  PVector body = null;

  int arrowLineColor = color(250, 150, 200, 255);
  int arrowHeadColor = color(255, 150, 50);
  float arrowHeadSize = 15;
  float arrowHeadAngle = 160;
  PShape arrowHead;

  boolean stylizedHead = true;


  Arrow(PVector _anchor, PVector _body) {
    this.anchor = _anchor.copy();
    this.body = _body.copy();
    this.head = PVector.add(this.anchor, this.body);
  }

  Arrow(float x1, float y1, float x2, float y2) {
    this.anchor = new PVector(x1, y1);
    this.head = new PVector(x2, y2);
    this.body = PVector.sub(this.head, this.anchor);
  }


   public void setArrow(float x1, float y1, float x2, float y2) {
    this.anchor = new PVector(x1, y1);
    this.head = new PVector(x2, y2);
    this.body = PVector.sub(this.head, this.anchor);
  }

   public void setArrow(PVector _anchor, PVector _body) {
    this.anchor = _anchor.copy();
    this.body = _body;
    this.head = PVector.add(this.anchor, this.body);
  }

   public void setAnchor(float x1, float y1) {
    this.anchor = new PVector(x1, y1);
    this.body = PVector.sub(this.head, this.anchor);
  }

   public void setBody(float x1, float y1) {
    this.body = new PVector(x1, y1);
    this.head = PVector.add(this.body, this.anchor);
  }

   public void show() {
    drawArrow(this.anchor.x, this.anchor.y, this.head.x, this.head.y);
  }


  private void drawArrow(float x1, float y1, float x2, float y2) {
    pushMatrix();
    pushStyle();
    stroke(this.arrowLineColor);
    strokeWeight(5);
    fill(200, 0, 50, 255);

    //Drawing the arrow head;
    float dX = x2 - x1; 
    float dY = y2 - y1;
    float theta = atan2(dY, dX);
    line(x1, y1, x2, y2);

    float leftX = x2+this.arrowHeadSize*cos(theta-radians(this.arrowHeadAngle)), leftY = y2+this.arrowHeadSize*sin(theta-radians(this.arrowHeadAngle));
    float rightX = x2+this.arrowHeadSize*cos(theta+radians(this.arrowHeadAngle)), rightY = y2+this.arrowHeadSize*sin(theta+radians(this.arrowHeadAngle));
    if (stylizedHead) {
      //Too Slow Eating up CPU Time! Perhaps may be feasible in Quasi Static Programs
      this.arrowHead = createShape();
      this.arrowHead.setFill(true);
      this.arrowHead.beginShape();
      this.arrowHead.fill(this.arrowHeadColor);
      this.arrowHead.stroke(this.arrowHeadColor);
      this.arrowHead.vertex(x2, y2);
      this.arrowHead.vertex(leftX, leftY);
      this.arrowHead.vertex(rightX, rightY);
      this.arrowHead.endShape(CLOSE);
      shape(this.arrowHead);
    } else {
      strokeWeight(5);
      stroke(this.arrowHeadColor);
      line(x2, y2, leftX, leftY);
      line(x2, y2, rightX, rightY);
      line(leftX, leftY, rightX, rightY);
    }
    stroke(50, 100, 255, 255);
    ellipse(x1, y1, 10, 10);
    popStyle();
    popMatrix();
  }
}
class Attractor {
  PVector position ;
  float mass ;
  String name = "Attractor";

  Attractor(PVector _position, float _mass) {
    this.position = _position.copy();
    this.mass = _mass;
  }

  Attractor() {
    this.position = new PVector(0,0);
    this.mass = 2000;
  }

   public void show() {
    pushStyle();
      noStroke();
      fill(233, 63, 21, 250);
      ellipse(this.position.x, this.position.y, 100, 100);
    popStyle();
  }
}
final public float G = 1.5f;
final public float PHI = 1.61803398875f; //Well For Dan Brown's shake
interface Focusable {
   boolean inFocus();
}
/* Fonts List in My System. Just for looking for good font to be used in the SideBar class
[0] "Adinatha Tamil Brahmi"
[1] "Agency FB"
[2] "Agency FB Bold"
[3] "Algerian"
[4] "Arial"
[5] "Arial Black"
[6] "Arial Bold"
[7] "Arial Bold Italic"
[8] "Arial Italic"
[9] "Arial Narrow"
[10] "Arial Narrow Bold"
[11] "Arial Narrow Bold Italic"
[12] "Arial Narrow Italic"
[13] "Arial Rounded MT Bold"
[14] "Arial Unicode MS"
[15] "Baskerville Old Face"
[16] "Bauhaus 93"
[17] "Bell MT"
[18] "Bell MT Bold"
[19] "Bell MT Italic"
[20] "Berlin Sans FB"
[21] "Berlin Sans FB Bold"
[22] "Berlin Sans FB Demi Bold"
[23] "Bernard MT Condensed"
[24] "Blackadder ITC"
[25] "Bodoni MT"
[26] "Bodoni MT Black"
[27] "Bodoni MT Black Italic"
[28] "Bodoni MT Bold"
[29] "Bodoni MT Bold Italic"
[30] "Bodoni MT Condensed"
[31] "Bodoni MT Condensed Bold"
[32] "Bodoni MT Condensed Bold Italic"
[33] "Bodoni MT Condensed Italic"
[34] "Bodoni MT Italic"
[35] "Bodoni MT Poster Compressed"
[36] "Book Antiqua"
[37] "Book Antiqua Bold"
[38] "Book Antiqua Bold Italic"
[39] "Book Antiqua Italic"
[40] "Bookman Old Style"
[41] "Bookman Old Style Bold"
[42] "Bookman Old Style Bold Italic"
[43] "Bookman Old Style Italic"
[44] "Bookshelf Symbol 7"
[45] "Bradley Hand ITC"
[46] "Britannic Bold"
[47] "Broadway"
[48] "Brush Script MT Italic"
[49] "Calibri"
[50] "Calibri Bold"
[51] "Calibri Bold Italic"
[52] "Calibri Italic"
[53] "Calibri Light"
[54] "Calibri Light Italic"
[55] "Californian FB"
[56] "Californian FB Bold"
[57] "Californian FB Italic"
[58] "Calisto MT"
[59] "Calisto MT Bold"
[60] "Calisto MT Bold Italic"
[61] "Calisto MT Italic"
[62] "Cambria"
[63] "Cambria Bold"
[64] "Cambria Bold Italic"
[65] "Cambria Italic"
[66] "Cambria Math"
[67] "Candara"
[68] "Candara Bold"
[69] "Candara Bold Italic"
[70] "Candara Italic"
[71] "Castellar"
[72] "Centaur"
[73] "Century"
[74] "Century Gothic"
[75] "Century Gothic Bold"
[76] "Century Gothic Bold Italic"
[77] "Century Gothic Italic"
[78] "Century Schoolbook"
[79] "Century Schoolbook Bold"
[80] "Century Schoolbook Bold Italic"
[81] "Century Schoolbook Italic"
[82] "Chiller"
[83] "Colonna MT"
[84] "Comic Sans MS"
[85] "Comic Sans MS Bold"
[86] "Comic Sans MS Bold Italic"
[87] "Comic Sans MS Italic"
[88] "Consolas"
[89] "Consolas Bold"
[90] "Consolas Bold Italic"
[91] "Consolas Italic"
[92] "Constantia"
[93] "Constantia Bold"
[94] "Constantia Bold Italic"
[95] "Constantia Italic"
[96] "Cooper Black"
[97] "Copperplate Gothic Bold"
[98] "Copperplate Gothic Light"
[99] "Corbel"
[100] "Corbel Bold"
[101] "Corbel Bold Italic"
[102] "Corbel Italic"
[103] "Courier New"
[104] "Courier New Bold"
[105] "Courier New Bold Italic"
[106] "Courier New Italic"
[107] "Curlz MT"
[108] "DKC Forever"
[109] "Dialog.bold"
[110] "Dialog.bolditalic"
[111] "Dialog.italic"
[112] "Dialog.plain"
[113] "DialogInput.bold"
[114] "DialogInput.bolditalic"
[115] "DialogInput.italic"
[116] "DialogInput.plain"
[117] "Ebrima"
[118] "Ebrima Bold"
[119] "Edwardian Script ITC"
[120] "Elephant"
[121] "Elephant Italic"
[122] "Engravers MT"
[123] "Eras Bold ITC"
[124] "Eras Demi ITC"
[125] "Eras Light ITC"
[126] "Eras Medium ITC"
[127] "Euclid"
[128] "Euclid Bold"
[129] "Euclid Bold Italic"
[130] "Euclid Extra"
[131] "Euclid Extra Bold"
[132] "Euclid Fraktur"
[133] "Euclid Fraktur Bold"
[134] "Euclid Italic"
[135] "Euclid Math One"
[136] "Euclid Math One Bold"
[137] "Euclid Math Two"
[138] "Euclid Math Two Bold"
[139] "Euclid Symbol"
[140] "Euclid Symbol Bold"
[141] "Euclid Symbol Bold Italic"
[142] "Euclid Symbol Italic"
[143] "Felix Titling"
[144] "Fences Plain"
[145] "Footlight MT Light"
[146] "Forte"
[147] "Franklin Gothic Book"
[148] "Franklin Gothic Book Italic"
[149] "Franklin Gothic Demi"
[150] "Franklin Gothic Demi Cond"
[151] "Franklin Gothic Demi Italic"
[152] "Franklin Gothic Heavy"
[153] "Franklin Gothic Heavy Italic"
[154] "Franklin Gothic Medium"
[155] "Franklin Gothic Medium Cond"
[156] "Franklin Gothic Medium Italic"
[157] "Freestyle Script"
[158] "French Script MT"
[159] "GIST-TMOTAbhirami Bold"
[160] "GIST-TMOTAbhirami BoldItalic"
[161] "GIST-TMOTAmala Bold"
[162] "GIST-TMOTAmala BoldItalic"
[163] "GIST-TMOTAppar Bold"
[164] "GIST-TMOTAppar BoldItalic"
[165] "GIST-TMOTChanakya Bold"
[166] "GIST-TMOTChanakya BoldItalic"
[167] "GIST-TMOTChanakya Italic"
[168] "GIST-TMOTChanakya Normal"
[169] "GIST-TMOTChandra Bold"
[170] "GIST-TMOTChandra BoldItalic"
[171] "GIST-TMOTHeena Bold"
[172] "GIST-TMOTHeena BoldItalic"
[173] "GIST-TMOTIlango Bold"
[174] "GIST-TMOTIlango Normal"
[175] "GIST-TMOTKalyani Bold"
[176] "GIST-TMOTKalyani BoldItalic"
[177] "GIST-TMOTKamal Bold"
[178] "GIST-TMOTKamal BoldItalic"
[179] "GIST-TMOTKamal Italic"
[180] "GIST-TMOTKamal Normal"
[181] "GIST-TMOTKannadasan Italic"
[182] "GIST-TMOTKannadasan Normal"
[183] "GIST-TMOTKannagi Bold"
[184] "GIST-TMOTKannagi BoldItalic"
[185] "GIST-TMOTKomala Bold"
[186] "GIST-TMOTKomala BoldItalic"
[187] "GIST-TMOTKrishnan Bold"
[188] "GIST-TMOTKumudam Normal"
[189] "GIST-TMOTLalitha Bold"
[190] "GIST-TMOTLalitha BoldItalic"
[191] "GIST-TMOTLalitha Italic"
[192] "GIST-TMOTLalitha Normal"
[193] "GIST-TMOTMadhura Bold"
[194] "GIST-TMOTMina Bold"
[195] "GIST-TMOTNambi Bold"
[196] "GIST-TMOTNambi BoldItalic"
[197] "GIST-TMOTNambi Italic"
[198] "GIST-TMOTNambi Normal"
[199] "GIST-TMOTPadma Bold"
[200] "GIST-TMOTPadma Normal"
[201] "GIST-TMOTParvathi Bold"
[202] "GIST-TMOTParvathi BoldItalic"
[203] "GIST-TMOTPattinathar Bold"
[204] "GIST-TMOTPattinathar BoldItalic"
[205] "GIST-TMOTPattinathar Italic"
[206] "GIST-TMOTPattinathar Normal"
[207] "GIST-TMOTSuman Bold"
[208] "GIST-TMOTSuman BoldItalic"
[209] "Gabriola"
[210] "Gadugi"
[211] "Gadugi Bold"
[212] "Garamond"
[213] "Garamond Bold"
[214] "Garamond Italic"
[215] "Georgia"
[216] "Georgia Bold"
[217] "Georgia Bold Italic"
[218] "Georgia Italic"
[219] "Gigi"
[220] "Gill Sans MT"
[221] "Gill Sans MT Bold"
[222] "Gill Sans MT Bold Italic"
[223] "Gill Sans MT Condensed"
[224] "Gill Sans MT Ext Condensed Bold"
[225] "Gill Sans MT Italic"
[226] "Gill Sans Ultra Bold"
[227] "Gill Sans Ultra Bold Condensed"
[228] "Gloucester MT Extra Condensed"
[229] "Goudy Old Style"
[230] "Goudy Old Style Bold"
[231] "Goudy Old Style Italic"
[232] "Goudy Stout"
[233] "Haettenschweiler"
[234] "Harlow Solid Italic"
[235] "Harrington"
[236] "HelvLight Regular"
[237] "High Tower Text"
[238] "High Tower Text Italic"
[239] "Impact"
[240] "Imprint MT Shadow"
[241] "Informal Roman"
[242] "Javanese Text"
[243] "Jokerman"
[244] "Juice ITC"
[245] "KaviriTSC"
[246] "KollidamTSC"
[247] "Kristen ITC"
[248] "Kunstler Script"
[249] "Lato Regular"
[250] "Leelawadee UI"
[251] "Leelawadee UI Bold"
[252] "Leelawadee UI Semilight"
[253] "Lucida Bright"
[254] "Lucida Bright Demibold"
[255] "Lucida Bright Demibold Italic"
[256] "Lucida Bright Italic"
[257] "Lucida Bright Regular"
[258] "Lucida Calligraphy Italic"
[259] "Lucida Console"
[260] "Lucida Fax Demibold"
[261] "Lucida Fax Demibold Italic"
[262] "Lucida Fax Italic"
[263] "Lucida Fax Regular"
[264] "Lucida Handwriting Italic"
[265] "Lucida Sans Demibold"
[266] "Lucida Sans Demibold Italic"
[267] "Lucida Sans Demibold Roman"
[268] "Lucida Sans Italic"
[269] "Lucida Sans Regular"
[270] "Lucida Sans Typewriter Bold"
[271] "Lucida Sans Typewriter Bold Oblique"
[272] "Lucida Sans Typewriter Oblique"
[273] "Lucida Sans Typewriter Regular"
[274] "Lucida Sans Unicode"
[275] "MS Gothic"
[276] "MS Mincho"
[277] "MS Outlook"
[278] "MS PGothic"
[279] "MS Reference Sans Serif"
[280] "MS Reference Specialty"
[281] "MS UI Gothic"
[282] "MT Extra"
[283] "MT Extra Tiger"
[284] "MV Boli"
[285] "Magneto Bold"
[286] "Maiandra GD"
[287] "Malgun Gothic"
[288] "Malgun Gothic Bold"
[289] "Malgun Gothic Semilight"
[290] "Marlett"
[291] "Matura MT Script Capitals"
[292] "Microsoft Himalaya"
[293] "Microsoft JhengHei"
[294] "Microsoft JhengHei Bold"
[295] "Microsoft JhengHei Light"
[296] "Microsoft JhengHei UI"
[297] "Microsoft JhengHei UI Bold"
[298] "Microsoft JhengHei UI Light"
[299] "Microsoft New Tai Lue"
[300] "Microsoft New Tai Lue Bold"
[301] "Microsoft PhagsPa"
[302] "Microsoft PhagsPa Bold"
[303] "Microsoft Sans Serif"
[304] "Microsoft Tai Le"
[305] "Microsoft Tai Le Bold"
[306] "Microsoft YaHei"
[307] "Microsoft YaHei Bold"
[308] "Microsoft YaHei Light"
[309] "Microsoft YaHei UI"
[310] "Microsoft YaHei UI Bold"
[311] "Microsoft YaHei UI Light"
[312] "Microsoft Yi Baiti"
[313] "MingLiU-ExtB"
[314] "MingLiU_HKSCS-ExtB"
[315] "Mistral"
[316] "Modern No. 20"
[317] "Mongolian Baiti"
[318] "Monospaced.bold"
[319] "Monospaced.bolditalic"
[320] "Monospaced.italic"
[321] "Monospaced.plain"
[322] "Monotype Corsiva"
[323] "Myanmar Text"
[324] "Myanmar Text Bold"
[325] "NSimSun"
[326] "Niagara Engraved"
[327] "Niagara Solid"
[328] "Nirmala UI"
[329] "Nirmala UI Bold"
[330] "Nirmala UI Semilight"
[331] "OCR A Extended"
[332] "Old English Text MT"
[333] "Onyx"
[334] "PMingLiU-ExtB"
[335] "Palace Script MT"
[336] "PalarTSC"
[337] "Palatino Linotype"
[338] "Palatino Linotype Bold"
[339] "Palatino Linotype Bold Italic"
[340] "Palatino Linotype Italic"
[341] "Papyrus"
[342] "Parchment"
[343] "Perpetua"
[344] "Perpetua Bold"
[345] "Perpetua Bold Italic"
[346] "Perpetua Italic"
[347] "Perpetua Titling MT Bold"
[348] "Perpetua Titling MT Light"
[349] "Playbill"
[350] "PonniTSC"
[351] "Poor Richard"
[352] "PorunaiTSC"
[353] "PothigaiTSC"
[354] "Pristina"
[355] "Rage Italic"
[356] "Ravie"
[357] "Roboto Light"
[358] "Rockwell"
[359] "Rockwell Bold"
[360] "Rockwell Bold Italic"
[361] "Rockwell Condensed"
[362] "Rockwell Condensed Bold"
[363] "Rockwell Extra Bold"
[364] "Rockwell Italic"
[365] "SansSerif.bold"
[366] "SansSerif.bolditalic"
[367] "SansSerif.italic"
[368] "SansSerif.plain"
[369] "Script MT Bold"
[370] "Segoe MDL2 Assets"
[371] "Segoe Print"
[372] "Segoe Print Bold"
[373] "Segoe Script"
[374] "Segoe Script Bold"
[375] "Segoe UI"
[376] "Segoe UI Black"
[377] "Segoe UI Black Italic"
[378] "Segoe UI Bold"
[379] "Segoe UI Bold Italic"
[380] "Segoe UI Emoji"
[381] "Segoe UI Historic"
[382] "Segoe UI Italic"
[383] "Segoe UI Light"
[384] "Segoe UI Light Italic"
[385] "Segoe UI Semibold"
[386] "Segoe UI Semibold Italic"
[387] "Segoe UI Semilight"
[388] "Segoe UI Semilight Italic"
[389] "Segoe UI Symbol"
[390] "Serif.bold"
[391] "Serif.bolditalic"
[392] "Serif.italic"
[393] "Serif.plain"
[394] "Showcard Gothic"
[395] "SimSun"
[396] "SimSun-ExtB"
[397] "Sitka Banner"
[398] "Sitka Banner Bold"
[399] "Sitka Banner Bold Italic"
[400] "Sitka Banner Italic"
[401] "Sitka Display"
[402] "Sitka Display Bold"
[403] "Sitka Display Bold Italic"
[404] "Sitka Display Italic"
[405] "Sitka Heading"
[406] "Sitka Heading Bold"
[407] "Sitka Heading Bold Italic"
[408] "Sitka Heading Italic"
[409] "Sitka Small"
[410] "Sitka Small Bold"
[411] "Sitka Small Bold Italic"
[412] "Sitka Small Italic"
[413] "Sitka Subheading"
[414] "Sitka Subheading Bold"
[415] "Sitka Subheading Bold Italic"
[416] "Sitka Subheading Italic"
[417] "Sitka Text"
[418] "Sitka Text Bold"
[419] "Sitka Text Bold Italic"
[420] "Sitka Text Italic"
[421] "Snap ITC"
[422] "Stencil"
[423] "Sylfaen"
[424] "Symbol"
[425] "Symbol Tiger"
[426] "Symbol Tiger Expert"
[427] "TSCu_SaiIndira"
[428] "Tahoma"
[429] "Tahoma Bold"
[430] "Tempus Sans ITC"
[431] "ThamirabaraniTSC"
[432] "Tiger"
[433] "Tiger Expert"
[434] "Times New Roman"
[435] "Times New Roman Bold"
[436] "Times New Roman Bold Italic"
[437] "Times New Roman Italic"
[438] "Trebuchet MS"
[439] "Trebuchet MS Bold"
[440] "Trebuchet MS Bold Italic"
[441] "Trebuchet MS Italic"
[442] "Tw Cen MT"
[443] "Tw Cen MT Bold"
[444] "Tw Cen MT Bold Italic"
[445] "Tw Cen MT Condensed"
[446] "Tw Cen MT Condensed Bold"
[447] "Tw Cen MT Condensed Extra Bold"
[448] "Tw Cen MT Italic"
[449] "Uni Ila.Sundaram-01"
[450] "Uni Ila.Sundaram-02"
[451] "Uni Ila.Sundaram-03"
[452] "Uni Ila.Sundaram-04"
[453] "Uni Ila.Sundaram-05"
[454] "Uni Ila.Sundaram-06"
[455] "Uni Ila.Sundaram-07"
[456] "Uni Ila.Sundaram-08"
[457] "Uni Ila.Sundaram-09"
[458] "Uni Ila.Sundaram-10"
[459] "Verdana"
[460] "Verdana Bold"
[461] "Verdana Bold Italic"
[462] "Verdana Italic"
[463] "Viner Hand ITC"
[464] "Vivaldi Italic"
[465] "Vladimir Script"
[466] "Webdings"
[467] "Wide Latin"
[468] "Wingdings"
[469] "Wingdings 2"
[470] "Wingdings 3"
[471] "Yu Gothic Bold"
[472] "Yu Gothic Light"
[473] "Yu Gothic Medium"
[474] "Yu Gothic Regular"
[475] "Yu Gothic UI Bold"
[476] "Yu Gothic UI Light"
[477] "Yu Gothic UI Regular"
[478] "Yu Gothic UI Semibold"
[479] "Yu Gothic UI Semilight"
*/
public class Planet {  
  private float preFrameRate;
  private float currentFrameRate;
  private float averageFrameRate;
  private float deltaTime = 1.0f;

  PVector position = new PVector();
  PVector oldPosition = new PVector();     // For Doing Verlet Integration.
  PVector velocity = new PVector();
  PVector acceleration = new PVector();
  PVector initialPosition = new PVector();

  Attractor myAttractor;
  ArrayList<PVector> orbitPoints = new ArrayList<PVector>();
  ArrayList<PolarPoint> orbitPolarPoints = new ArrayList<PolarPoint>();

  float orbitalPeriod=-1;
  float maxRadius = -1;
  float minRadius = 5000000;
  float minAngle = 0;
  float maxAngle = 0;
  int minIndex = 0;
  int maxIndex = 0;
  float orbitalEccentricity = 0;
  float semiMajorAxis = 0;
  float semiMinorAxis = 0;
  PVector apoapsis = new PVector(); //Farthest point from the attractor
  PVector periapsis = new PVector(); //Closest point to the attractor
  PVector orbitCenter = new PVector(); //Center point of the elliptical orbit

  String  orbitDescriptor;

  final private float threshold = 0.5f;
  final private int minOrbitPointCount = 100;
  final private int maxOrbitPointCount = 50000;


  float mass;
  float size = 60;
  String name;
  int planetColor ;

  Arrow velocityArrow = new Arrow(0, 0, 0, 0);
  Arrow accelerationArrow  = new Arrow(0, 0, 0, 0);
  final static float velocityArrowScale = 40;

  boolean highlighted = false;

  //Constructors

  Planet(PVector _position, PVector _velocity, float _mass) {
    this.position = _position.copy();
    this.initialPosition = this.position.copy();
    this.oldPosition = this.initialPosition.copy();//???? Will this work?
    this.velocity = _velocity.copy();
    this.velocityArrow = new Arrow(this.position, this.velocity.copy().mult(velocityArrowScale));
    this.mass = _mass;
    this.name = "Planet";
    this.orbitDescriptor = "";
    this.preFrameRate = frameRate;
    this.currentFrameRate = frameRate;
    pushStyle();
    colorMode(HSB);
    this.planetColor = color(random(255), 255, 255, 255);
    popStyle();
   
  }

  Planet(PVector _position, PVector _velocity, float _mass, Attractor _attractor) {
    this(_position, _velocity, _mass);
    this.myAttractor = _attractor;
    this.initVerlet();
    calcOrbit(_attractor);
    
  }

  Planet(PVector _position, float _mass) {
    this.position = _position.copy();
    this.initialPosition = this.position.copy();
    this.oldPosition = this.initialPosition.copy();
    this.velocity = PVector.random2D();
    this.velocityArrow = new Arrow(this.position, this.velocity.copy().mult(velocityArrowScale));
    this.mass = _mass;
    this.name = "Planet";
    pushStyle();
    colorMode(HSB);
    this.planetColor = color(random(255), 255, 255, 255);
    popStyle();
   
  }

  Planet() {
    this.position.x = random(width);
    this.position.y = random(height);
    this.initialPosition = this.position.copy();
    this.oldPosition = this.initialPosition.copy();
    this.velocity = PVector.random2D();
    this.velocity.setMag(random(0.5f, 5.0f));
    this.velocityArrow = new Arrow(this.position, this.velocity.copy().mult(velocityArrowScale));
    this.mass = random(0.05f, 0.5f);
    this.name = "Planet";
    pushStyle();
    colorMode(HSB);
    this.planetColor = color(random(255), 255, 255, 255);
    popStyle();
   
  }

  //Displayer
   public void show() {
    pushStyle();
    fill(this.planetColor);
    noStroke();
    ellipse(this.position.x, this.position.y, this.size, this.size);
    if (this.highlighted) {
      pushStyle();
      float beginRed = red(this.planetColor);
      float beginGreen = green(this.planetColor);
      float beginBlue = blue(this.planetColor);
      float endRed = 255-red(this.planetColor);
      float endGreen = 255-green(this.planetColor);
      float endBlue = 255-blue(this.planetColor);
      int beginColor = color(beginRed, beginGreen, beginBlue);
      int endColor = color(endRed, endGreen, endBlue);
      noFill();
      strokeWeight(3);
      for (float i=0; i<=1; i+=0.05f) {
        stroke(lerpColor(beginColor, endColor, i), map(i, 0, 1, 100, 255)); 
        ellipse(this.position.x, this.position.y, this.size+50*i, this.size+50*i);
      }
      popStyle();
    }
    popStyle();
  }
  
   public void initVerlet() {
    //What is wrong?
    //float deltaTime = 1.0f; //60/frameRate; Haa ! Verlet integration can't have variable deltaTime It is not simplectic?
    try {
      this.calcForce(this.myAttractor);
      PVector tempOldPosition = this.oldPosition.copy();
      this.position = tempOldPosition.add(this.velocity.mult(this.deltaTime)).add(this.acceleration.mult(0.5f*deltaTime*this.deltaTime));
    }
    catch(Exception e){
      e.printStackTrace();
    }
  }

  //Update : Do Physics...Verlet Integration to be implemented in future. NOW: 14.07.2018
   public void update() {
    //NEW VERLET
    verletIntegrate(this.deltaTime);
 
    velocityArrow.setArrow(this.position, this.velocity.copy().mult(velocityArrowScale));
    accelerationArrow.setArrow(this.position, this.acceleration.copy().mult(velocityArrowScale*30));
    this.acceleration.setMag(0);
  }

 public void linearIntegrate(float deltaTime){
    this.velocity.add(PVector.mult(this.acceleration, deltaTime));
    this.position.add(PVector.mult(this.velocity, deltaTime));
  
}

  public void verletIntegrate(float deltaTime) {
    PVector tempPosition = this.position.copy();
    PVector tempAcceleration = this.acceleration.copy();
    
    this.position.mult(2).sub(this.oldPosition).add(tempAcceleration.mult(deltaTime*deltaTime));
    this.oldPosition = tempPosition.copy();
    this.velocity = PVector.sub(this.position,this.oldPosition).mult(1/deltaTime);
    
 }

  //CalcForce : Calculate Force using Newton's Law of Gravitation. The Great Inverse Square Law.
   public void calcForce(Attractor attractor) {
    float dist = PVector.dist(this.position, attractor.position);
    PVector radialVector = PVector.sub(attractor.position, this.position).setMag(1);
    acceleration.set(radialVector).setMag(G*attractor.mass*this.mass/(dist*dist));
  }

  //Orbit calculations. Pretty messy now but works good...
   public void calcOrbit(Attractor attractor) {
    PVector radial = PVector.sub(this.position, attractor.position);
    float initHeading = radial.heading()*180/PI+180.0f;
    float heading; 
    float magnitude;
    int count = 0;
    do {
      PVector pos = this.position.copy();
      this.orbitPoints.add(pos);
      // this.calcForce(attractor);
      // this.update();

      radial = PVector.sub(this.position, attractor.position);
      magnitude = radial.mag();
      heading = radial.heading2D()*180/PI+180.0f;

      this.orbitPolarPoints.add(new PolarPoint(magnitude,heading));

       this.calcForce(attractor);
       this.update();


      if (magnitude>this.maxRadius) {
        this.maxRadius = magnitude;
        this.maxAngle = heading-180.0f;
        this.maxIndex = count;
      }
      if (magnitude<this.minRadius) {
        this.minRadius = magnitude;
        this.minAngle = heading-180.0f;
        this.minIndex = count;
      }
      count++;
    } while ((abs(heading-initHeading)>this.threshold || count < this.minOrbitPointCount) && !(count>this.maxOrbitPointCount));
  
    if (orbitPoints.size()<maxOrbitPointCount) {
      this.orbitalPeriod = (orbitPoints.size())*(1.0f/30.0f);
    }

    this.orbitalEccentricity = (this.maxRadius-this.minRadius)/(this.maxRadius+this.minRadius);
    this.apoapsis = orbitPoints.get(maxIndex);
    this.periapsis = orbitPoints.get(minIndex);
    this.orbitCenter = PVector.lerp(this.apoapsis, this.periapsis, 0.5f);
    this.semiMajorAxis = PVector.sub(this.periapsis, this.apoapsis).mag()/2;
    this.semiMinorAxis = this.semiMajorAxis*sqrt(1-this.orbitalEccentricity*this.orbitalEccentricity);
    float kepler_aCubeByTSquare = pow(this.semiMajorAxis, 3)/pow(this.orbitalPeriod, 2);

    this.orbitDescriptor += "Orbital Parameters\n";
    this.orbitDescriptor += "Orbital Period          : "+String.format("%.02f", this.orbitalPeriod)+ " Sec\n";
    this.orbitDescriptor += "Eccentricity            : "+String.format("%.02f", this.orbitalEccentricity)+ "\n";
    this.orbitDescriptor += "Semi Major Axis         : "+String.format("%.02f", this.semiMajorAxis) + "\n";
    this.orbitDescriptor += "Semi Minor Axis         : "+String.format("%.02f", this.semiMinorAxis) + "\n";
    this.orbitDescriptor += "Kepler III Law Constant : "+String.format("%.02f", kepler_aCubeByTSquare) + "\n";
    this.orbitDescriptor += "Max Radius              : "+String.format("%.02f", this.maxRadius) + "\n";
    this.orbitDescriptor += "Min Radius              : "+String.format("%.02f", this.minRadius) + "\n";
    
    this.orbitDescriptor += "Max Angle               : "+String.format("%.02f", this.maxAngle) + "\u00B0" + "\n"; // "\u00B0" ---> Degree Symbol
    this.orbitDescriptor += "Min Angle               : "+String.format("%.02f", this.minAngle) + "\u00B0" + "\n"; 
    //this.orbitPoints.clear(); //If you need orbitPoints don't clear it !!!
  }

   public void showOrbit(boolean showPoints) {
    pushStyle();
    strokeWeight(2);
    stroke(this.planetColor);
    noFill();
    pushMatrix();
    translate(this.orbitCenter.x, this.orbitCenter.y);
    rotate(radians(this.minAngle));
    ellipse(0, 0, 2*this.semiMajorAxis, 2*this.semiMinorAxis);
    popMatrix();
    try {
      if (showPoints) {
        stroke(0, 0, 255, 255);
        strokeWeight(20);
        point(orbitPoints.get(minIndex).x, orbitPoints.get(minIndex).y);
        stroke(255, 100, 0, 255);
        point(orbitPoints.get(maxIndex).x, orbitPoints.get(maxIndex).y);
        stroke(255, 100, 255, 255);
        point(this.orbitCenter.x, this.orbitCenter.y);
        popStyle();
      }
    }
    catch(Exception e){
      e.printStackTrace();
    }
  }

   public void showRadial(Attractor a) {
    pushStyle();
    stroke(this.planetColor);
    line(a.position.x, a.position.y, this.position.x, this.position.y);
    popStyle();
  }

   public void showVelocity() {
    this.velocityArrow.show();
  }

   public void showAcceleration() {
    this.accelerationArrow.show();
  }

   public void showVelocity(PVector anchor) {
    velocityArrow.setArrow(anchor, this.velocity.copy().mult(velocityArrowScale));
    this.velocityArrow.show();
  }

   public void setHighlighted(boolean _highlighted) {
    this.highlighted = _highlighted;
  }
}//CLASS_END
class PolarPoint {
  float radius;
  float angle;

  PolarPoint(float _radius, float _angle) {
    this.radius = _radius;
    this.angle = _angle;
  }

  PolarPoint(PVector cartesianPoint) {
    this.angle  = cartesianPoint.heading2D() ;
    this.radius = PVector.dist(cartesianPoint, new PVector(0, 0));
  }

   public float getRadius() {
    return this.radius;
  }

   public float geAngle() {
    return this.angle;
  }

   public PVector getCartesian() {
    float x = this.radius*cos(this.angle);
    float y = this.radius*sin(this.angle);
    return new PVector(x, y);
  }
  
   public void rotatePoint(float _angle){
    this.angle += _angle;
  }

   public void dilatePoint(float scaleFactor){
    this.radius *= scaleFactor;
  }
}
//Have to be developed into a potential UI Component in Future.


public class SideBar extends Widget implements Focusable
{

  private final byte TO_LEFT  = -1;
  private final byte TO_RIGHT = +1;
  private final byte TO_REVERSE = -1;

  protected PApplet granny;

  protected float handleWidth; //Width of the handle to pull out the side bar
  protected float animSpeed ;  // Easing speed of the sliding action of the side bar

  protected int handleColor; // Color of the handle

  private boolean latched = true; // Property to keep track of latching condition of the sidebar
  private byte slide = TO_LEFT;   // To determine sliding direction on mouse click multiplied by -1. 
                                  // Hence start with -1 for sliding out
  private float drawWidth;

  SideBar(PApplet _granny) {
    super();
    this.granny = _granny;
    this.granny.registerMethod("draw", this);
    this.granny.registerMethod("mouseEvent", this);

    this.animSpeed = 0.02f;
    this.barWidth = 2*width/3;
    this.barHeight = height/2;
    this.handleWidth = 15;
    this.leftPos = -this.barWidth + this.handleWidth;
    this.topPos = height*this.relTopPos;
    this.drawWidth = this.barWidth - this.handleWidth;
    this.barColor = color(10, 25, 10, 32);
    this.handleColor = color(255, 0, 255, 64);
    this.self = createGraphics((int)this.barWidth, (int)this.barHeight);
    this.init();
  }

  SideBar(PApplet _granny, float _topPos, float _barWidth, float _barHeight) {
    super(_topPos, _barWidth, _barHeight);

    this.granny = _granny;
    this.granny.registerMethod("draw", this);
    this.granny.registerMethod("mouseEvent", this);

    this.handleWidth = 15;
    this.leftPos = -this.barWidth + this.handleWidth;
    this.drawWidth = this.barWidth - this.handleWidth;

    this.barColor = color(20, 25, 50, 128);
    this.handleColor = color(255, 0, 255, 16);
    this.self = createGraphics((int)this.barWidth, (int)this.barHeight);
    this.animSpeed = 0.2f;

    this.init();
  }

   public void init() {
    pushStyle();
    self.smooth(4);
    self.beginDraw();
    self.background(this.barColor); 
    self.noStroke();
    self.fill(this.handleColor);
    //New hande Drawing...
    pushStyle();
    self.noFill();
    //self.strokeJoin(BEVEL);
    float beginX = this.barWidth-this.handleWidth/2-1;

    for (float i=-this.handleWidth/2; i<this.handleWidth/2; i++) {
      self.stroke(red(this.handleColor), green(this.handleColor), blue(this.handleColor)
        , abs(155-abs(map(i, -handleWidth/2, handleWidth/2, -155, 155))));
      this.self.line(beginX+i, 0, beginX+i, this.barHeight);
    }
    popStyle();
    //
    //self.rect(this.barWidth-this.handleWidth, 0, handleWidth, this.barHeight); //Deprecate
    if (this.img != null) {
      pushStyle();
      self.tint(255, 192);

      float imgAspectRatio = PApplet.parseFloat(this.img.width) / PApplet.parseFloat(this.img.height);
      float imgRenderHeight = min(this.barWidth,this.barHeight);
      float imgRenderWidth = imgRenderHeight*imgAspectRatio;

      self.image(this.img, 0, 0, imgRenderWidth ,  imgRenderHeight);
      popStyle();

    }
    self.endDraw();

    popStyle();
    if (this.children.size()>0) {

      for (Widget w : this.children) {
        w.init();
        self.image(w.self, w.leftPos, w.topPos);
      }
    } //is this needed or not SERIOUSLY? in render this is required but not here I hope...
    this.buffer = this.self.get();
  }

   public void render() {
    pushMatrix();

    if (this.children.size()>0) {
      for (Widget w : this.children) {
        w.render();
      }
    }

    image(this.self, this.leftPos, this.topPos);
    float target = (this.slide<0)?(-this.barWidth+this.handleWidth):(0);
    float diff = abs(target-this.leftPos);
    if (!this.latched) {
      this.leftPos += this.slide*(diff*this.animSpeed);
    }

    float handlePosition = this.leftPos + this.barWidth-this.handleWidth;
    float handlePositionMin = 0;
    float handlePositionMax  = this.barWidth-this.handleWidth;

    if (handlePosition < handlePositionMin) {
      this.latched = true;
      this.leftPos = -this.barWidth+this.handleWidth;
    }

    if (handlePosition > handlePositionMax) {
      this.latched = true;
      this.leftPos = 0;
    }
    popMatrix();
  }

   public void slideOut() {
    this.latched = false;
    this.slide = TO_RIGHT;
  }

   public void slideIn() {
    this.latched = false;
    this.slide = TO_LEFT;
  }

   public void drawHandle() {
    //NEW
    self.noStroke();
    self.fill(this.handleColor);
    self.rect(this.barWidth-this.handleWidth, 0, handleWidth, this.barHeight);
    this.init();
    //NEW
  }

   public boolean inFocus() {
    return (
      mouseX > this.leftPos && 
      mouseX < (this.leftPos + this.barWidth ) && 
      mouseY > this.topPos && 
      mouseY < (this.topPos + this.barHeight)) ;
  }




   public void addChild(Widget child) {
    this.children.add(child);
    child.setParent(this);
    child.init();
  }

  public void draw() {
    this.render();
  }

  public void mouseEvent(MouseEvent event) {
    //int x = event.getX();
    //int y = event.getY();

    switch (event.getAction()) {
    case MouseEvent.PRESS:
      this.mousePressedHandler();     
      // do something for the mouse being pressed
      break;
    case MouseEvent.RELEASE:
      this.mouseReleasedHandler();
      // do something for mouse released
      break;
    case MouseEvent.CLICK:
      this.mouseClickedHandler();
      // do something for mouse clicked
      break;
    case MouseEvent.DRAG:
      this.mouseDraggedHandler();
      // do something for mouse dragged
      break;
    case MouseEvent.MOVE:
      // do something for mouse moved
      break;
    }
  }

   public void mouseDraggedHandler() {
  }

   public void mousePressedHandler() {
    if (this.inFocus()) {
      try {
      } 
      catch(Exception e) {
        e.printStackTrace();
      }
      //?????
    }
  }

   public void mouseReleasedHandler() {
    if (this.inFocus()) {
      try {
      } 
      catch(Exception e) {
        e.printStackTrace();
      }
      //?????
    }
  }

   public void mouseClickedHandler() {
    float handlePosition = this.leftPos + this.barWidth-this.handleWidth;
    if (mouseX > handlePosition && mouseX < handlePosition+this.handleWidth && this.inFocus()) {
      this.latched = false;
      this.slide *= TO_REVERSE;
    }
    try
    {
      for (Widget w : this.children) {
        w.mouseClickedHandler();
      }
    }
    catch(Exception e) {
      println("No Children Yet!");
    }
  }

  //---------------------------------------------------------------------------------------------//
  //-----------------------------------GETTERS & SETTERS-----------------------------------------//

  //----------------------------------------GETTERS----------------------------------------------//

   public PApplet getGranny() {
    return this.granny;
  }

   public float getHandleWidth() {
    return this.handleWidth;
  }

   public float getDrawWidth() {
    return this.drawWidth;
  }

   public float getAnimSpeed() {
    return this.animSpeed;
  }

   public int getHandleColor() {
    return this.handleColor;
  }

   public boolean isLatched() {
    return this.latched;
  }

  //----------------------------------------SETTERS------------------------------------------------//



   public void setHandleColor(int c) {
    this.handleColor = color(red(c), green(c), blue(c), 128);
    this.init();
  }

   public void setHandleWidth(float _handleWidth) {
    this.handleWidth = _handleWidth;
  }

   public void setImage(PImage _image) {
    this.img = _image;
    this.init();
  }
}//EOC

public class TextBar extends Widget implements Focusable {

  protected PFont font;               // Font used for text o/p
  protected String textContent;       // Text to be displayed in the text bar
  protected int textBackColor;      // Color of the text surface
  protected int textColor;          // Color of the text
  protected float textHeight;         // Text Height for alignment purposes
  protected float textLeading = 20;
  protected float leftPadding = 10;
  protected float rightPadding = 10;
  protected float topPadding = 10;
  protected float bottomPadding = 10;
  protected float textSize = 14;
  protected boolean borderless = true;
  protected boolean textDelimited ;   //is this necessary?
  protected char delimiter;


  TextBar(float _leftPos, float _topPos, float _barWidth, float _barHeight, Widget _parent) {
    super(_leftPos, _topPos, _barWidth, _barHeight);
    this.initFields();
    this.parent = _parent;
    this.parent.addChild(this);
    this.init();
  }

  TextBar(float _leftPos, float _topPos, float _barWidth, float _barHeight) {
    super(_leftPos, _topPos, _barWidth, _barHeight);
    this.initFields();
    this.init();
  }

  private void initFields() {
    this.textContent = "";
    this.textBackColor = color(15, 50, 20, 225);
    this.textColor = color(255, 255, 255, 255);
    this.font = createFont("Constantia Bold", this.textSize, true);
    this.textHeight = textAscent()+textDescent()+this.font.getSize();
    this.barColor = color(red(this.textBackColor), green(this.textBackColor), blue(this.textBackColor), 0); //Bar Color Should be 
    this.self = createGraphics((int)this.barWidth, (int)this.barHeight);
    this.self.smooth(8);
  }
  
   public void init() {
    pushStyle();
    try {
      self.smooth(8);
      self.beginDraw();
      self.fill(this.textBackColor); 
      self.rectMode(CORNER);
      self.background(this.barColor);
      if (this.borderless) {
        self.noStroke();
      } else {
        self.strokeWeight(2);
        self.stroke(255, 100, 50, 128);
      }
      
      self.strokeJoin(ROUND);
    
      self.rect(1, 1, this.barWidth-2, this.barHeight-2,20);
      self.endDraw();
      
      popStyle();
      printText(this.textContent);
    }
    catch(Exception e) {
      e.printStackTrace();
      println("Exception in Textbar init() method");
    }
  }

   public void render() {
 
    try{

    this.parent.self.beginDraw();
    this.parent.self.pushStyle();

    //If I'm the first child, It is my duty to clear up the mess before rendering me...
    if (this.parent.children.indexOf(this) == 0) //This is my long sought solution...Thank God...
    {
      this.parent.self.clear();
      this.parent.self.image(this.parent.buffer, 0, 0);
    }
    
    this.parent.self.image(this.self, this.leftPos, this.topPos); 
    this.parent.self.popStyle();
    this.parent.self.endDraw();
    }
    catch(Exception e){
      e.printStackTrace();
    }
  }


   public void printText(String str) {
    if (str.length()==0) return;
    if (this.textDelimited) {
      try {
        this.printTextDelimited(str);
      }
      catch(Exception e) {
        e.printStackTrace();
        this.setText("FORMAT ERROR !");
      }
      return;
    } 
    
    pushStyle();
    self.beginDraw();
    self.rectMode(CORNER);
    if (this.font != null) {
      self.textFont(this.font);
    } else {
      self.textSize(this.textSize);
    }
    self.noStroke();
    float textLeadingFactor = 1.0f;
    this.textLeading = this.textHeight/textLeadingFactor;
    self.textLeading(this.textLeading);

    float fieldWidth = (this.barWidth-this.rightPadding-this.leftPadding);
    float fieldHeight = (this.barHeight-this.topPadding-this.bottomPadding);

    self.textAlign(LEFT, TOP);
    self.fill(this.textColor); 
    self.textSize(this.textSize);
    self.text(str, this.leftPadding, this.topPadding, 
      fieldWidth, fieldHeight);

    self.endDraw();
    popStyle();
  }

   public void printTextDelimited(String str) {
    if (textContent.length()==0) return;  //???? 0 or 1?
    //Restructuring the str into two parts based on the delimiter ':'
    String[] splitString = this.split(str);
    String headerStr = splitString[0];
    String leftStr = "" + splitString[1];
    String rightStr = "" + splitString[2];

    pushStyle();

    self.beginDraw();
    self.rectMode(CORNER);

    if (this.font != null) {
      self.textFont(this.font);
    } else {
      self.textSize(this.textSize);
    }

    self.noStroke();
    float textLeadingFactor = 1.0f;
    this.textLeading = this.textHeight/textLeadingFactor;
    self.textLeading(this.textLeading);

    float fieldWidth = (this.barWidth/2-this.rightPadding-this.leftPadding);
    float fieldHeight = (this.barHeight-this.topPadding-this.bottomPadding);

    //Beginning Header Text Surface
    float headerHeight = 2*fieldHeight/str.split("\n").length;
    float fieldWidthHeader = (this.barWidth-this.rightPadding-this.leftPadding);
    float fieldHeightHeader = (headerHeight-this.topPadding-2*this.bottomPadding); //Changed on 21.10.202. Multiplied this.bottomPadding by 2.
    fieldHeight -= headerHeight;

    self.textAlign(CENTER, CENTER);
    self.fill(this.textBackColor);
    self.fill(this.textColor); 
    self.textSize(this.textSize);
    //NEW //Beautiful but source of bugs... To see just chnage the topPadding to 15
    self.stroke(255);
    self.strokeWeight(2);
    self.line(this.leftPadding,this.bottomPadding+this.topPadding+fieldHeightHeader,this.leftPadding+fieldWidthHeader,this.bottomPadding+this.topPadding+fieldHeightHeader);    
    //NEW    
    self.text(headerStr, this.leftPadding, this.topPadding, 
              fieldWidthHeader, fieldHeightHeader);

    //Begining left text surface
    self.textSize(this.textSize);
    self.textAlign(RIGHT, TOP); 
    self.fill(this.textColor); 
    self.text(leftStr, this.leftPadding, headerHeight+this.topPadding, fieldWidth, fieldHeight);
    
    //Beginning right text surface
    self.textAlign(LEFT, TOP);
    self.fill(this.textBackColor);
    self.fill(this.textColor);
    self.text(rightStr, this.barWidth/2+this.leftPadding, headerHeight+this.topPadding, fieldWidth, fieldHeight);

    //Beginning Underlining the firstline //Headache? Yes Unsolved Mystery //Well going to deprecate ===> Find Another Way...
    self.stroke(200, 250, 255);
    self.strokeWeight(2);
    if (this.textContent.length() != 0) {

      //self.line(this.leftPadding, this.textHeight+this.topPadding-this.textLeading/(4*textLeadingFactor), 
      //  this.leftPadding+self.textWidth(str.split("\n")[0]), this.textHeight+this.topPadding-this.textLeading/(4*textLeadingFactor));
      //self.line(this.leftPadding, this.textHeight+1, 
      //    this.leftPadding+self.textWidth(str.split("\n")[0]), this.textHeight+1);
    }
    self.endDraw();
    popStyle();
  }

   public boolean inFocus() { 
    float relX  = mouseX - this.parent.leftPos;
    float relY = mouseY - this.parent.topPos;
    return (relX > this.leftPos &&
            relX < (this.leftPos + this.barWidth) &&
            relY > this.topPos && 
            relY < (this.topPos + this.barHeight));
  }

   public void mouseClickedHandler() {
  }

   public void addChild(Widget child) {
    children.add(child);
  }

   public void setParent(Widget w) {
    this.parent = w;
  }

  private String[] split(String str)
  {
    String[] splitString = new String[3];
    String headerStr = "";
    String leftStr = "";
    String rightStr = "";
    //Playing to display text easthetically...
    String[] lines = str.split("\n");
    String regX = "\\s+" + this.delimiter;
    for (int i=1; i<lines.length; i++) {
      String[] lineParts = lines[i].split(regX);//Regular Expression Saved the Day !
      //(This RegX means split at ":" preceded by one or more white spaces)
      leftStr += lineParts[0]+"\n";
      rightStr += this.delimiter+" "+lineParts[1]+"\n";
    }
    headerStr = lines[0];
    splitString[0] = headerStr;
    splitString[1] = leftStr;
    splitString[2] = rightStr;
    return splitString;
  }
   public void setText(String str) {
    this.textContent = str;
    this.textDelimited = false;
    this.init();
  }

   public void setTextSize(float _textSize) {
    this.textSize = _textSize;
    this.init();
  }

   public void addText(String str) {
    this.textContent += str;
    this.textDelimited = false;
    this.init();
  }

   public void setText(String str, char _delimiter) {
    this.textContent = str;
    this.delimiter = _delimiter;
    this.textDelimited = true;
    this.init();
  }

   public void setleftPadding(float _leftPadding) {
    this.leftPadding = _leftPadding;
    this.init();
  }
}
/*

*  Display LRL Vector
*  Incorporate Verlet Integration  - From Iteration 23 - This is a mess why? 
   /* Problem Solved ! Most Important thing in Verlet Integration is that deltaTime should be a constant ...
    If not the numerical integral would diverge.
    One disadvantage is that deltaTime can't be made to depend on frameRate. 
    Hence leading to varying speed of animated objects. But this problem can be remedied by averaging over two 
    consequent frameRates I hope.



*/
public abstract  class Widget {
  protected Widget parent = null;
  protected ArrayList<Widget> children = new ArrayList<Widget>();
  protected PGraphics self; //Main graphic surface to draw on...
  protected PImage buffer = null;//Buffer to hold self

  protected float barWidth; //Width of the Widget
  protected float barHeight; //Height of the Widget
  protected float leftPos;  //x coordinate of the left extreme of the Widget
  protected float topPos; //y coordinate of the upper extreme of the Widget
  protected float relTopPos=0; // Relative position from the parent/container top as a fraction of parents height
  protected float relLeftPos=0; // Relative position from the parent/container left as a fraction of parents width
  protected int barColor ; // Background color of the Widget
  protected PImage img; // Optional background image can be set.

  Widget(float _topPos, float _barWidth, float _barHeight) {

    this.topPos = _topPos;
    this.barWidth = _barWidth;
    this.barHeight = _barHeight;
  }

  Widget(float _leftPos, float _topPos, float _barWidth, float _barHeight) {
    this.leftPos = _leftPos;
    this.topPos = _topPos;
    this.barWidth = _barWidth;
    this.barHeight = _barHeight;
  }


  Widget() {
  }

  protected abstract void init();
  protected abstract void render();

  //abstract boolean inFocus();
  protected abstract void mouseClickedHandler();
  protected abstract void addChild(Widget child);

  //---------------------------------------------------------------------------------------------//
  //-----------------------------------GETTERS & SETTERS-----------------------------------------//

  //----------------------------------------GETTERS----------------------------------------------//
  
   public Widget getParent() {
    return this.parent;
  }

   public ArrayList<Widget> getChildren() {
    return this.children;
  }
  
   public PImage getBuffer() {
    return this.buffer;
  }
  
   public float getBarWidth() {
   return this.barWidth; 
  }
  
   public float getBarHeight() {
   return this.barHeight; 
  }
  
   public int getBarColor() {
    return this.barColor;
  }

  //----------------------------------------SETTERS----------------------------------------------//

   public void setParent(Widget _parent) {
    this.parent = _parent;
  }
  
   public void setBarColor(int _barColor) {
    this.barColor = _barColor;
  }
}//EOAC

/*
Tamil Unicode 
 "\u0B85\u0BAE\u0B82\u0BAE\u0BBE " ---> ammA
 Project Idea
 
 
 */


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "PlanetaryAdventures25" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
